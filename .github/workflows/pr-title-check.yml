name: PR Title Check

on:
  pull_request:
    types: [opened, edited, synchronize, reopened]

jobs:
  validate-title:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Check PR title format
        uses: amannn/action-semantic-pull-request@v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          # Require conventional commit format
          types: |
            feat
            fix
            docs
            chore
            refactor
            test
            ci
            perf
            build
            revert
          # Require a scope is optional
          requireScope: false
          # Allow custom scopes
          scopes: |
            core
            tools
            workflows
            deps
          # Subject validation
          subjectPattern: ^(?![A-Z]).+$
          subjectPatternError: |
            The subject "{subject}" found in the pull request title "{title}"
            must start with a lowercase letter.
          # Ignore merge commits and dependency bot
          ignoreLabels: |
            dependencies
            skip-validation
          # Custom message on failure
          wip: false

      - name: Determine version bump
        id: version
        run: |
          set -euo pipefail

          PR_TITLE="${{ github.event.pull_request.title }}"
          CURRENT_VERSION=$(node -p "require('./package.json').version")

          echo "current=$CURRENT_VERSION" >> $GITHUB_OUTPUT

          # Determine bump type from PR title
          if [[ "$PR_TITLE" =~ ^feat!: ]] || [[ "$PR_TITLE" =~ BREAKING ]]; then
            BUMP="major"
          elif [[ "$PR_TITLE" =~ ^feat ]]; then
            BUMP="minor"
          elif [[ "$PR_TITLE" =~ ^fix ]]; then
            BUMP="patch"
          else
            BUMP="none"
          fi

          echo "bump=$BUMP" >> $GITHUB_OUTPUT

          # Calculate next version
          if [ "$BUMP" != "none" ]; then
            IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
            
            case "$BUMP" in
              major)
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              minor)
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              patch)
                PATCH=$((PATCH + 1))
                ;;
            esac
            
            NEXT_VERSION="${MAJOR}.${MINOR}.${PATCH}"
            echo "next=$NEXT_VERSION" >> $GITHUB_OUTPUT
          else
            echo "next=none" >> $GITHUB_OUTPUT
          fi

      - name: Comment version info
        uses: actions/github-script@v7
        with:
          script: |
            const bump = '${{ steps.version.outputs.bump }}';
            const current = '${{ steps.version.outputs.current }}';
            const next = '${{ steps.version.outputs.next }}';

            let emoji = 'âœ…';
            let message = '## âœ… PR Title Valid\n\n';

            if (bump === 'none') {
              emoji = 'ðŸ“';
              message += `**No version bump** - Documentation or configuration change\n\n`;
              message += `Current version: \`${current}\`\n`;
              message += `After merge: No release will be created`;
            } else {
              let bumpType = bump.toUpperCase();
              if (bump === 'major') emoji = 'ðŸš¨';
              if (bump === 'minor') emoji = 'âœ¨';
              if (bump === 'patch') emoji = 'ðŸ›';
              
              message += `${emoji} **${bumpType}** version bump detected\n\n`;
              message += `Current version: \`${current}\`\n`;
              message += `After merge: \`${next}-alpha.1\` â†’ draft release\n`;
              message += `When published: \`${next}\` â†’ npm @latest\n\n`;
              
              if (bump === 'major') {
                message += `> âš ï¸ **Breaking change detected** - This will increment the major version.`;
              }
            }

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('PR Title Valid')
            );

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: message
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: message
              });
            }
