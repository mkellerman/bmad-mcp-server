/**
 * Tests for manifest deduplication logic
 * Verifies that tools and tasks are properly deduplicated with priority-based resolution
 *
 * Test setup:
 * - Project source: tests/fixtures (priority 1 - highest)
 * - User source: tests/fixtures/custom (priority 2 - lower) [simulated via ~/.bmad]
 *
 * Note: The custom source manifests need to be pre-generated by the manifest generator.
 * In production, this happens during BMAD installation. For these tests, we validate
 * that the deduplication logic works correctly with the available manifests.
 *
 * What we test:
 * ✅ Priority-based deduplication (project overrides user for same name+module)
 * ✅ All required fields are populated correctly
 * ✅ Deduplication key is module:name (not just name)
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { ResourceLoaderGit } from '../../src/core/resource-loader.js';
import { join } from 'node:path';

describe('Manifest Deduplication', () => {
  let loader: ResourceLoaderGit;
  const fixturesPath = join(process.cwd(), 'tests', 'fixtures', 'bmad');

  beforeEach(async () => {
    // Initialize loader with 'auto' mode to test multi-source deduplication
    // This tests the deduplication logic works correctly across sources
    loader = new ResourceLoaderGit(fixturesPath, undefined, 'auto');
  });

  describe('Tool Deduplication', () => {
    it('should deduplicate tools with same name across sources, keeping highest priority', async () => {
      const tools = await loader.listToolsWithMetadata();

      // Find shard-doc - should exist only once
      const shardDocs = tools.filter((t) => t.name === 'shard-doc');
      expect(shardDocs).toHaveLength(1);

      // Should be the project version (priority 1), not the custom/user version (priority 2)
      const shardDoc = shardDocs[0];
      expect(shardDoc.module).toBe('core');
      expect(shardDoc.displayName).toBe('Shard Document');
      expect(shardDoc.description).toContain('Splits large markdown documents');
      expect(shardDoc.path).toBe('bmad/core/tools/shard-doc.xml');

      // Should NOT be the custom version
      expect(shardDoc.description).not.toContain('Custom version');
      expect(shardDoc.displayName).not.toContain('Custom');
    });

    it('should load project tools from manifest', async () => {
      const tools = await loader.listToolsWithMetadata();

      // Should have at least the project tool
      expect(tools.length).toBeGreaterThanOrEqual(1);

      // Project shard-doc should be present
      const shardDoc = tools.find((t) => t.name === 'shard-doc');
      expect(shardDoc).toBeDefined();
      expect(shardDoc?.module).toBe('core');
    });

    it('should have all required fields populated', async () => {
      const tools = await loader.listToolsWithMetadata();

      tools.forEach((tool) => {
        expect(tool.name).toBeTruthy();
        expect(tool.displayName).toBeTruthy();
        expect(tool.module).toBeTruthy();
        expect(tool.path).toBeTruthy();
        expect(typeof tool.standalone).toBe('boolean');
      });
    });
  });

  describe('Task Deduplication', () => {
    it('should deduplicate tasks with same name across sources, keeping highest priority', async () => {
      const tasks = await loader.listTasksWithMetadata();

      // Find index-docs - should exist only once
      const indexDocs = tasks.filter((t) => t.name === 'index-docs');
      expect(indexDocs).toHaveLength(1);

      // Should be the project version (priority 1), not the custom/user version (priority 2)
      const indexDoc = indexDocs[0];
      expect(indexDoc.module).toBe('core');
      expect(indexDoc.displayName).toBe('Index Docs');
      expect(indexDoc.description).toContain('Generates or updates an index');
      expect(indexDoc.path).toBe('bmad/core/tasks/index-docs.xml');

      // Should NOT be the custom version
      expect(indexDoc.description).not.toContain('Custom version');
    });

    it('should load project tasks from manifest', async () => {
      const tasks = await loader.listTasksWithMetadata();

      // Should have at least the project tasks
      expect(tasks.length).toBeGreaterThanOrEqual(4);

      // Verify project tasks are present
      expect(tasks.find((t) => t.name === 'adv-elicit')).toBeDefined();
      expect(tasks.find((t) => t.name === 'index-docs')).toBeDefined();
      expect(tasks.find((t) => t.name === 'validate-workflow')).toBeDefined();
      expect(tasks.find((t) => t.name === 'workflow')).toBeDefined();
    });

    it('should have all required fields populated', async () => {
      const tasks = await loader.listTasksWithMetadata();

      tasks.forEach((task) => {
        expect(task.name).toBeTruthy();
        expect(task.displayName).toBeTruthy();
        expect(task.module).toBeTruthy();
        expect(task.path).toBeTruthy();
        expect(typeof task.standalone).toBe('boolean');
      });
    });
  });

  describe('Multi-Source Priority', () => {
    it('should respect priority order: project > user', async () => {
      const tools = await loader.listToolsWithMetadata();
      const tasks = await loader.listTasksWithMetadata();

      // shard-doc: project should win over user/custom
      const shardDoc = tools.find((t) => t.name === 'shard-doc');
      expect(shardDoc).toBeDefined();
      expect(shardDoc?.description).toContain('Splits large markdown');
      expect(shardDoc?.description).not.toContain('Custom');

      // index-docs: project should win over user/custom
      const indexDoc = tasks.find((t) => t.name === 'index-docs');
      expect(indexDoc).toBeDefined();
      expect(indexDoc?.description).toContain('Generates or updates');
      expect(indexDoc?.description).not.toContain('Custom');
    });

    it('should use deduplication key of module:name', async () => {
      const tools = await loader.listToolsWithMetadata();
      const tasks = await loader.listTasksWithMetadata();

      // Each tool/task should appear only once per module:name combination
      const toolKeys = tools.map((t) => `${t.module}:${t.name}`);
      const uniqueToolKeys = new Set(toolKeys);
      expect(toolKeys.length).toBe(uniqueToolKeys.size);

      const taskKeys = tasks.map((t) => `${t.module}:${t.name}`);
      const uniqueTaskKeys = new Set(taskKeys);
      expect(taskKeys.length).toBe(uniqueTaskKeys.size);
    });
  });
});
